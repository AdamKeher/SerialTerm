        /// <summary>
        ///     Simple serial port terminal program.
        ///     (c)2021 AKsevenFour
        ///     https://github.com/AdamKeher/SerialTerm
        /// </summary>
        /// <param name="invocationContext"></param>
        /// <param name="listPorts">List all serial ports</param>
        /// <param name="port">Set the serial port to listen on</param>
        /// <param name="baud">Set serial port baud rate</param>
        /// <param name="dataBits">Sets the standard length of data bits per byte (5..[8])</param>
        /// <param name="parity">Sets the parity-checking protocol ([None] | Mark | Even | Odd | Space)</param>
        /// <param name="stopBits">Sets the standard number of stopbits per byte ([One] | OnePointFive | Two | )</param>
        /// <param name="handshake">Specifies the control protocol used in establishing a serial port communication ([None] | RTS | XonXoff | RTSXonXoff)</param>
        /// <param name="disconnectExit">Exit terminal on disconnection</param>
        static void Main2(
            InvocationContext invocationContext,
            bool listPorts = false,
            string port = null,
            int baud = 115200,
            int dataBits = 8,
            string parity = "none",
            string stopBits = "one",
            string handshake = "none",
            bool disconnectExit = false)
        {
            Console.WriteLine("\u001b[31mSerial\u001b[31;1mTERM\u001b[37m v0.2 (c)2021 \u001b[32m\u001b[7mAKsevenFour\u001b[0m.");

            Program.invocationContext = invocationContext;

            if (listPorts)
            {
                Console.WriteLine("Serial Ports");
                Console.WriteLine("------------");
                ListPorts();
                return;
            }

            // validate inputs
            if (ValidateInputs(dataBits, parity, stopBits, handshake))
                return;

            // setup serial port
            _serialPort = new SerialPort()
            {
                PortName = port ?? SetPortName(),
                BaudRate = baud,
                DataBits = dataBits,
                Parity = SetParity(parity),
                StopBits = SetStopBits(stopBits),
                Handshake = SetHandshake(handshake),
                ReadTimeout = 500,
                WriteTimeout = 500
            };
            _serialPort.DataReceived += new SerialDataReceivedEventHandler(DataReceivedHandler);
            _serialPort.ErrorReceived += new SerialErrorReceivedEventHandler(ErrorReceivedHandler);

            // open serial port
            Console.WriteLine("Connecting to: {0}", SerialPortDetails());

            try
            {
                _serialPort.Open();
            }
            catch (Exception)
            {
                Console.WriteLine($"Failed to open {_serialPort.PortName}");
            }

            // wait while receiving data and handle disconnection and control keys
            bool _reconnecting = false;
            bool _paused = false;
            _continue = true;
            while (_continue)
            {
                // handle serial disconnection and reconnection
                if (!_paused && !_serialPort.IsOpen)
                {
                    try
                    {
                        _serialPort.Open();
                        _reconnecting = false;
                        Console.WriteLine("Reconnected.");
                    }
                    catch (System.IO.FileNotFoundException)
                    {
                        if (!_reconnecting) Console.WriteLine("Disconnected.");
                        if (disconnectExit)
                            return;
                        _reconnecting = true;
                    }
                    catch (System.IO.IOException) { }
                }

                // control keys
                if (Console.KeyAvailable)
                {
                    _paused = ProcessKeys(_paused);
                }

                Thread.Sleep(100);
            }
        }











        How do you get invocationContext without using DragonFruit














       static int Main(string[] args)
        {
            // Create a root command with some options
            var rootCommand = new RootCommand()
            {
                new Option<bool>(
                    "--list-ports",
                    getDefaultValue: () => false,
                    description: "List all serial ports"),
                new Option<string>(
                    "--port",
                    "Set the serial port to listen on"),
                new Option<int>(
                    "--baud",
                    getDefaultValue: () => 115200,
                    "Set serial port baud rate"),
                new Option<int>(
                    "--data-bits",
                    getDefaultValue: () => 8,
                    "Sets the standard length of data bits per byte (5..8)"),
                new Option<string>(
                    "--parity",
                    getDefaultValue: () => "None",
                    "Sets the parity-checking protocol (None | Mark | Even | Odd | Space)"),
                new Option<string>(
                    "--stop-bits",
                    getDefaultValue: () => "One",
                    "Sets the standard number of stopbits per byte (One | OnePointFive | Two)"),
                new Option<string>(
                    "--handshake",
                    getDefaultValue: () => "None",
                    "Specifies the control protocol used in establishing a serial port communication (None | RTS | XonXoff | RTSXonXoff)"),
                new Option<bool>(
                    "--disconnect-exit",
                    getDefaultValue: () => false,
                    "Exit terminal on disconnection")
            };

            rootCommand.Description = "SimpleTerm - Simple serial port terminal program. (c)2021 AKsevenFour - https://github.com/AdamKeher/SerialTerm";

            // Note that the parameters of the handler method are matched according to the names of the options
            rootCommand.Handler = CommandHandler.Create<InvocationContext, bool, string, int, int, string, string, string, bool>((context, listPorts, port, baud, dataBits, parity, stopBits, handshake, disconnectExit) =>
            {
                Program.invocationContext = context;

                if (listPorts)
                {
                    ListPorts();
                    return;
                }

                Console.WriteLine($"The value for listPorts is: {listPorts}");
                Console.WriteLine($"The value for port is: {port}");
                Console.WriteLine($"The value for baud is: {baud}");
                Console.WriteLine($"The value for databits is: {dataBits}");
                Console.WriteLine($"The value for parity is: {parity}");
                Console.WriteLine($"The value for stopbits is: {stopBits}");
                Console.WriteLine($"The value for handshake is: {handshake}");
                Console.WriteLine($"The value for disconnectExit is: {disconnectExit}");
            });

            // Parse the incoming args and invoke the handler
            return rootCommand.InvokeAsync(args).Result;
        }
